chapter3练习
=======================================



编程作业
--------------------------------------

简单安全检查
+++++++++++++++++++++++++++++++

ch2 中，我们实现了第一个系统调用 ``sys_write``，这使得我们可以在用户态输出信息。但是 os 在提供服务的同时，还有保护 os 本身以及其他用户程序不受错误或者恶意程序破坏的功能。

由于还没有实现虚拟内存，我们可以在用户程序中指定一个属于其他程序字符串，并将它输出，这显然是不合理的，因此我们要对 sys_write 做检查：

- sys_write 仅能输出位于程序本身内存空间内的数据，否则报错。

stride 调度算法
+++++++++++++++++++++++++++++++++++++++++

ch3 中我们实现的调度算法十分简单。现在我们要为我们的 os 实现一种带优先级的调度算法：stride 调度算法。

算法描述如下:

(1) 为每个进程设置一个当前 stride，表示该进程当前已经运行的“长度”。另外设置其对应的 pass 值（只与进程的优先权有关系），表示对应进程在调度后，stride 需要进行的累加值。

(2) 每次需要调度时，从当前 runnable 态的进程中选择 stride 最小的进程调度。对于获得调度的进程 P，将对应的 stride 加上其对应的步长 pass。

(3) 一个时间片后，回到上一步骤，重新调度当前 stride 最小的进程。

可以证明，如果令 P.pass = BigStride / P.priority 其中 P.priority 表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。证明过程我们在这里略去，有兴趣的同学可以在网上查找相关资料。

其他实验细节：

- stride 调度要求进程优先级 :math:`\geq 2`，所以设定进程优先级 :math:`\leq 1` 会导致错误。
- 进程初始 stride 设置为 0 即可。
- 进程初始优先级设置为 16。

为了实现该调度算法，内核还要增加 set_prio 系统调用

.. code-block:: rust

    // 输入参数：进程优先级，要求 prio >= 2
    // 返回值：如果输入合法则返回 0，否则返回 -1
    fn sys_set_priority(prio: isize) -> isize;

实验要求
+++++++++++++++++++++++++++++++++++++++++

- 完成分支: ch3。

- 通过所有测例：

lab3 有 2 类测例，在 os 目录下执行 ``make run TEST=1`` 检查基本 syscall 的实现，执行 ``make run TEST=2`` 检查 stride 调度算法。

.. attention::

    为了让大家能在本编程作业中使用 ``Vec`` 等数据结构，我们利用第三方库 ``buddy_system_allocator`` 为大家实现了堆内存分配器，相关代码位于 ``heap_alloc`` 模块。

    背景知识： `Rust 中的动态内存分配 <https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter4/1rust-dynamic-allocation.html>`_


.. note::

    你的实现只需且必须通过测例，建议读者感到困惑时先检查测例。

实验检查
++++++++++++++++++++++++++++++++++++++++

- 实验目录要求

.. code-block::

   ├── os(内核实现)
   │   ├── Cargo.toml(配置文件)
   │   └── src(所有内核的源代码放在 os/src 目录下)
   │       ├── main.rs(内核主函数)
   │       └── ...
   ├── reports (不是 report)
   │   ├── lab1.md/pdf
   │   └── ...
   ├── ...

测试时 os/makefile 文件和 user 文件夹将被替换。

简答作业
--------------------------------------------
1. 请自行阅读 ch3 的 os/Makefile 和 user/Makefile 文件，描述在 os 目录下执行 ``make run`` 时执行了哪些命令。

2. 请问 riscv64 支持哪些中断 / 异常？如何判断进入内核是由于中断还是异常？为了方便 os 处理，Ｍ 态软件会将 S 态异常/中断委托给 S 态软件，请指出有哪些寄存器记录了委托信息，rustsbi 委托了哪些异常/中断？（RustSBI 在启动时输出了什么？）

3. 请通过 gdb 简单跟踪从机器加电到跳转到 0x80200000 的简单过程，描述重要的跳转即可。程序是如何进入 S 态的？
  
   - 事实上进入 rustsbi (0x80000000) 之后就不需要使用 gdb 调试了。可以直接阅读 `代码 <https://github.com/rustsbi/rustsbi-qemu/blob/main/rustsbi-qemu/src/main.rs>`_ 。
   - 可以使用 Makefile 中的 ``make debug`` 指令。
   - 一些可能用到的 gdb 指令：
       - ``x/10i 0x80000000`` : 显示 0x80000000 处的10条汇编指令。
       - ``x/10i $pc`` : 显示即将执行的10条汇编指令。
       - ``x/10xw 0x80000000`` : 显示 0x80000000 处的10条数据，格式为16进制32bit。
       - ``info register``: 显示当前所有寄存器信息。
       - ``info r t0``: 显示 t0 寄存器的值。
       - ``break funcname``: 在目标函数第一条指令处设置断点。
       - ``break *0x80200000``: 在 0x80200000 出设置断点。
       - ``continue``: 执行直到碰到断点。
       - ``si``: 单步执行一条汇编指令。

4. 深入理解 `trap.S <https://github.com/rcore-os/rCore-Tutorial-v3/blob/ch2/os/src/trap/trap.S>`_ 中两个函数 ``__alltraps`` 和 ``__restore`` 的作用，并回答如下几个问题:

   1. L40：刚进入 ``__restore`` 时，``a0`` 代表了什么值。请指出 ``__restore`` 的两种使用情景。

   2. L46-L51：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。
      
      .. code-block:: riscv

         ld t0, 32*8(sp)
         ld t1, 33*8(sp)
         ld t2, 2*8(sp)
         csrw sstatus, t0
         csrw sepc, t1
         csrw sscratch, t2

   3. L53-L59：为何跳过了 ``x2`` 和 ``x4``？ 

      .. code-block:: riscv

         ld x1, 1*8(sp)
         ld x3, 3*8(sp)
         .set n, 5
         .rept 27
            LOAD_GP %n
            .set n, n+1
         .endr

   4. L63：该指令之后，``sp`` 和 ``sscratch`` 中的值分别有什么意义？

      .. code-block:: riscv

         csrrw sp, sscratch, sp

   5. ``__restore``：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

   6. L13：该指令之后，``sp`` 和 ``sscratch`` 中的值分别有什么意义？

      .. code-block:: riscv

         csrrw sp, sscratch, sp

   7. 从 U 态进入 S 态是哪一条指令发生的？

5. stride 算法深入
   
   stride 算法原理非常简单，但是有一个比较大的问题。例如两个 pass = 10 的进程，使用 8bit 无符号整形储存 stride， p1.stride = 255, p2.stride = 250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。

   - 实际情况是轮到 p1 执行吗？为什么？

   我们之前要求进程优先级 >= 2 其实就是为了解决这个问题。可以证明，**在不考虑溢出的情况下**, 在进程优先级全部 >= 2 的情况下，如果严格按照算法执行，那么 STRIDE_MAX – STRIDE_MIN <= BigStride / 2。

   - 为什么？尝试简单说明（传达思想即可，不要求严格证明）。


报告要求
-------------------------------

- 简单总结你实现的功能（200字以内，不要贴代码）。
- 完成问答题。
- (optional) 你对本次实验设计及难度/工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言。
